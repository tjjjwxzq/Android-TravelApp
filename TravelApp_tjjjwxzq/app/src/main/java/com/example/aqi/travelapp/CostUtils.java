package com.example.aqi.travelapp;

/**
 * Created by aqi on 2/11/15.
 */
import com.google.common.base.Predicate;
import com.google.common.collect.Collections2;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

/*************************************************************************************************
 * Contains some utility methods needed by the itinerary planner
 * METHODS:
 * deepContainsArray: convenience method for checking if a list of arrays of objects contains a
 *                    given array
 * MatchAll: convenience method for checking if all values in an array match a given value
 * getTime: returns the time given a mode of transport and edge
 * getCost: returns the cost given a mode of transport and edge
 * getTotalTime: returns the total time given modes of transport and an itinerary
 * getTotalCost: returns the total cost given modes of transport and an itinerary
 * TimeCostAve: calculates the time-cost average of a given node (over all transport modes)
 * TotalTimeCostAve: calculates the total time-cost average of an itinerary
 * nextshortestEdge: given an itinerary and a list of shortedges, return the shortest edge not
 *                   already in that list, as measured by type (time-cost-ave or walking time)
 *************************************************************************************************/

public class CostUtils {

    private static final String TAG = "CostUtils";


    /**
     *Convenience method for checking if a list of arrays of objects contains a given array
     *Have to implement this because arrlist.contains uses .equals() to check equality
     *But this does only shallow checking. To check equality of arrays of objects, one should use
     *Arrays.deepEquals
     * */
    public static boolean deepContainsArray(List<? extends Object[]> list, Object[] oarr)
    {
        for(Object[] objarr:list)
        {
            if(Arrays.deepEquals(objarr,oarr))
            {
                return true;
            }
        }

        return false;

    }

    /**
     * Convenince method for checking if all values in an array match a given value
     * or whether none of them match a given value
     * Since we can't use Arrays.stream from Java8
     * @param mode all match a given value or none match a given value
     * @param intarr array to check
     * @param value value to check against
     * @return boolean value
     */
    static boolean MatchAll(int mode, int[] intarr, int value)
    {
        for(int num:intarr)
        {
            if(mode==1)
            {
                if(num != value)
                    return false;
            }
            else
            {
                if(num == value)
                    return false;
            }
        }

        return true;
    }

    /******************************************************************************
     * Average time-cost is used for the nearest-neighbour algorithm, where the
     * nearest neighbout is determined in terms of the time-cost average
     *
     * This is also used for a faster computation of the optimal itinerary
     * generated by the brute force algorithm - thus not brute-forcing it
     * all the way
     *
     * Might implement a true brute-force optimal finder as well
     * (Didn't do it)
     * ***************************************************************************/

    /**
     * Returns the time for given mode of transport between two modes
     * @param mode
     * @param fromNode
     * @param toNode
     * @return
     */
    public static int getTime(int mode, String fromNode, String toNode)
    {
        return Destinations.TIME_ARR[mode][Destinations.DESTINATION_MAP.get(fromNode)][Destinations.DESTINATION_MAP.get(toNode)];
    }

    /**
     * REturns the cost for a given mode of transport between two nodes
     * @param mode
     * @param fromNode
     * @param toNode
     * @return
     */
    public static double getCost(int mode, String fromNode, String toNode)
    {
        return Destinations.COST_ARR[mode][Destinations.DESTINATION_MAP.get(fromNode)][Destinations.DESTINATION_MAP.get(toNode)];
    }

    /**
     * Returns the total time given an itinerary and the transport modes
     * between each node
     * @param modes
     * @param itinerary
     * @return
     */
    public static int getTotalTime(int[] modes, ArrayList<String> itinerary)
    {
        int total=0;
        for(int i =0; i < modes.length; i++)
        {
            total += getTime(modes[i], itinerary.get(i), itinerary.get(i==modes.length-1?0:i+1));
        }

        return total;
    }

    /**
     * Returns the total cost given an itinerary and the transport modes
     * between each node
     * @param modes
     * @param itinerary
     * @return
     */
    public static double getTotalCost(int[] modes, ArrayList<String> itinerary)
    {
        double total=0;
        for(int i =0; i<modes.length; i++)
        {
            total+= getCost(modes[i], itinerary.get(i),itinerary.get(i==modes.length-1?0:i+1));
        }

        return total;
    }


    /**
     * Returns the time cost average of travelling between two nodes
     * @param fromNode
     * @param toNode
     * @return
     */
    public static double TimeCostAve(String fromNode, String toNode)
    {
        double walkTimeCost = 1.0*Destinations.TIME_ARR[0][Destinations.DESTINATION_MAP.get(fromNode)][
                Destinations.DESTINATION_MAP.get(toNode)];
        double publicTimeCost = Destinations.COST_ARR[1][Destinations.DESTINATION_MAP.get(fromNode)][
                Destinations.DESTINATION_MAP.get(toNode)]*Destinations.TIME_ARR[1][Destinations.DESTINATION_MAP.get(fromNode)][
                Destinations.DESTINATION_MAP.get(toNode)];
        double taxiTimeCost = Destinations.COST_ARR[2][Destinations.DESTINATION_MAP.get(fromNode)][
                Destinations.DESTINATION_MAP.get(toNode)]*Destinations.TIME_ARR[2][Destinations.DESTINATION_MAP.get(fromNode)][
                Destinations.DESTINATION_MAP.get(toNode)];

        return (walkTimeCost+publicTimeCost+taxiTimeCost)/3;

    }

    /**
     * Returns the total time cost average of a given itinerary
     * where the nodes are assumed to be traversed int the given order
     * @param path
     * @return
     */
    public static double TotalTimeCostAve(ArrayList<String> path)
    {
        double total = 0;
        for(int i =0; i<path.size(); i++)
        {
            if (i==path.size()-1)
            {
                total += TimeCostAve(path.get(i),path.get(0));
            }
            else
                total += TimeCostAve(path.get(i), path.get(i+1));
        }
        return total;
    }

    /**
     * Returns the shortest edge in an itinerary
     * that is not already in the shortedges array
     * @param type determines the method with which to evaluate 'shortness': by
     *             time-cost averate or walking time
     * @param itinerary
     * @param shortedges
     * @return
     */
    public static String[] nextshortestEdge(String type, ArrayList<String> itinerary, ArrayList<String[]> shortedges)
    {
        double timecostave = -1.0;
        double newtimecostave = 0;
        String[] edge = new String[2];
        String[] testedge = new String[2];

        for(int i =0; i<itinerary.size();i++)
        {
            newtimecostave = type.equals("time-cost-ave")?TimeCostAve(itinerary.get(i), itinerary.get(i==itinerary.size()-1?0:i+1)):
                    getTime(0,itinerary.get(i),itinerary.get(i==itinerary.size()-1?0:i+1));
            testedge[0] = itinerary.get(i);
            testedge[1] = itinerary.get(i==itinerary.size()-1?0:i+1);

            for(String node:testedge)
            if((timecostave == -1.0 || newtimecostave < timecostave ) && !deepContainsArray(shortedges,testedge))
            {
                timecostave = newtimecostave;
                edge[0]= itinerary.get(i);
                edge[1] = itinerary.get(i==itinerary.size()-1?0:i+1);


            }
        }

        return edge;
    }


    /********************************************************************************************
     * Once given an optimal itinerary computed based on the time-cost average, the actual
     * mode of transport between each node has to be determined, and is constrained by the
     * budget
     *
     * The algorithm to determine the mode between each node starts by assuming taxi
     * for every edge; while the budget is exceeded, find the shortest edge in terms
     * of time-cost average, and check if the walking time is less than 15 min
     * If yes, change mode to walking, else change to bus, then check whether the budget
     * is exceeded; repeat until budget is no longer exceeded
     *
     * *****************************************************************************************/

    /**
     * Returns the transport modes as an array of integers; 0: walk, 1: public transport; 2:taxi
     * Actually returns a few possible transport modes arrays
     * Originally intended to give user choice to choose from a few
     * The default optimizes time as long as the cost is under budget,
     * but cheaper but less time-optimal possibilities are also
     * found by this method and returned
     * @param itinerary
     * @param budget
     * @return
     */
    public static ArrayList<ArrayList<int[]>> getTransportMode(final ArrayList<String> itinerary, double budget)
    {
        //ArrayList of possible overbudget and withinbudget modes
        ArrayList<int[]> ob_possiblemodes = new ArrayList<int[]>();
        ArrayList<int[]> wb_possiblemodes = new ArrayList<int[]>();

        //Set initial modes all to taxi
        int[] modes = new int[itinerary.size()];
        for(int i=0; i<modes.length;i++)
            modes[i] = 2;

        double totalcost = getTotalCost(modes,itinerary);
        String[] shortestedge = new String[2];
        ArrayList<String[]> shortedges = new ArrayList<String[]>();

        while(true)
        {
            shortestedge = nextshortestEdge("time-cost-ave",itinerary, shortedges);
            shortedges.add(shortestedge);

            //If walking takes less than 15 minutes, then walk
            if(Destinations.TIME_ARR[0][Destinations.DESTINATION_MAP.get(shortestedge[0])][Destinations.DESTINATION_MAP.get(shortestedge[1])] <= 15)
            {
                modes[itinerary.indexOf(shortestedge[0])] = 0;
                totalcost = getTotalCost(modes,itinerary);
            }
            else //if not, take public transport
            {
                modes[itinerary.indexOf(shortestedge[0])] = 1;
                totalcost = getTotalCost(modes,itinerary);
            }

            if(totalcost<=budget)
            {
                wb_possiblemodes.add(modes.clone());//have to clone modes so that I don't end up assigning the reference
            }

            if(totalcost>budget && totalcost<=budget+10)//parameterize this maybe
            {
                ob_possiblemodes.add(modes.clone());
            }

            //Don't evaluate all under budget nodes as it will slow the program
            //5 candidates are enough, and from them choose those with worthwhile tradeoffs
            if(wb_possiblemodes.size()>5)
                break;

            //Ran through all edges once but still less than 5 possible modes
            // (None of the modes are taxi)
            //Arrays.stream is in Java8, which is not supported in Android Studio
            if(MatchAll(0, modes, 2))
                break;
        }

        shortedges.clear();

        if(wb_possiblemodes.size()<5)
        {
            while(true)
            {
                shortestedge = nextshortestEdge("walking time",itinerary, shortedges);
                shortedges.add(shortestedge);
                System.out.println("After no taxi, shortestedge" + shortestedge[0]+" "+shortestedge[1]);

                modes[itinerary.indexOf(shortestedge[0])] = 0;
                totalcost = getTotalCost(modes,itinerary);

                if(totalcost<=budget)
                {
                    wb_possiblemodes.add(modes.clone());
                }

                if(totalcost>budget && totalcost<=budget+10)
                {
                    ob_possiblemodes.add(modes.clone());
                }

                if(wb_possiblemodes.size()>5)
                    break;

                //Ran through all the edges and changed all to walking
                if(MatchAll(1, modes, 0))
                    break;

            }

        }

        //Lambdas only in Java8; unsupported in Android Studio
        //ArrayList.sort() is also only Java8
        //Use Collections.sort(List, Comparator) instead
        Collections.sort(wb_possiblemodes, new Comparator<int[]>() {
            public int compare(int[] mode1, int[] mode2) {

                if(getTotalTime(mode1,itinerary)==getTotalTime(mode2,itinerary)) return 0;
                return getTotalTime(mode1, itinerary)<getTotalTime(mode2,itinerary)?-1:1;
            }
        });
        System.out.println("wb_possiblemodes before removal");
        for(int[] m:wb_possiblemodes)
        {
            for(int num:m)
                System.out.print(num + " ");

            System.out.println("");
        }
        System.out.println("ob_possiblemodes before removal");
        for(int[] m:ob_possiblemodes)
        {
            for(int num:m)
                System.out.print(num + " ");

            System.out.println("");
        }
        int[] modes_optimum = wb_possiblemodes.remove(0);//handle the optimum and the rest separately
        final double totalcost_optimum = getTotalCost(modes_optimum, itinerary);
        final int totaltime_optimum = getTotalTime(modes_optimum, itinerary);

        // removeIf is Java8, which is not yet supported in Android Studio
        // Use Collections2 class of Guava library
        // Lambdas also not supported: define an anonymous Predicate
        // Ignore the IDEs suggestion to change to lambda!
        // Won't work unless you use gradle-retrolambda
        // Type cast since Collections2.filter returns type Collections<E>
        wb_possiblemodes = new ArrayList<int[]>(Collections2.filter(wb_possiblemodes, new Predicate<int[]>() {
            @Override
            public boolean apply(int[] m) {
                return getTotalTime(m, itinerary) - totaltime_optimum >= 30;
                //either use this as cutoff, or let user specify a desired total travelling time? if the user is unreasonable, just return the optimum mode
            }
        }));
        ob_possiblemodes = new ArrayList<int[]>(Collections2.filter(ob_possiblemodes, new Predicate<int[]>() {
            @Override
            public boolean apply(int[] m) {
                return (totaltime_optimum - getTotalTime(m,itinerary))/(getTotalCost(m,itinerary)-totalcost_optimum) <= 2;
                //parameterize this also maybe; what ratio does the user think is worthwhile?
            }
        }));

        //return an arraylist containing modes_optimum(as ArrayList<int[]>), wb_possiblemodes with modes_optimum removed, and ob_possiblemodes
        ArrayList<int[]> wrappedmodes_optimum = new ArrayList<int[]>();
        wrappedmodes_optimum.add(modes_optimum);
        ArrayList<ArrayList<int[]>> allpossiblemodes = new ArrayList<ArrayList<int[]>>(Arrays.asList(wrappedmodes_optimum, wb_possiblemodes, ob_possiblemodes));
        return allpossiblemodes;


    }


}
